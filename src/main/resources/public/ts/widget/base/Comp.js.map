{"version":3,"file":"Comp.js","sourceRoot":"","sources":["Comp.ts"],"names":[],"mappings":"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","sourcesContent":["console.log(\"Comp.ts\");\n\nimport * as React from \"react\";\nimport * as ReactDOM from \"react-dom\";\nimport { CompImpl } from \"./CompImpl\";\n\n//todo-1: don't worry, this way of getting singletons is only temporary, because i haven't converted\n//this file over to using the Factory yet\ndeclare var util, domBind, tag;\n\nexport abstract class Comp extends React.Component implements CompImpl {\n\n    private static guid: number = 0;\n\n    static idToCompMap: { [key: string]: Comp } = {};\n    attribs: Object;\n\n    /* Note: NULL elements are allowed in this array and simply don't render anything, and are required to be tolerated and ignored */\n    children: Comp[];\n\n    /* State tells us if the widget is currently about to re-render itself as soon as it can */\n    renderPending: boolean = false;\n\n    /* These are primarily used by Buttons and MenuItems based on enablement updater */\n    enabled: boolean = true;\n    visible: boolean = true;\n\n    isEnabledFunc: Function;\n    isVisibleFunc: Function;\n\n    constructor(attribs: Object, private isReact: boolean = false) {\n        super({});\n        this.attribs = attribs || {};\n        this.children = [];\n\n        /* If an ID was specifically provided, then use it, or else generate one */\n        let id = (<any>this.attribs).id || \"c\" + Comp.nextGuid();\n        (<any>this.attribs).id = id;\n\n        //This map allows us to lookup the Comp directly by its ID similar to a DOM lookup\n        Comp.idToCompMap[id] = this;\n    }\n\n    /* Function refreshes all enablement and visibility based on current state of app */\n    refreshState(): void {\n        //todo-1: Eventually we will make this a smart routine which does a minimal-only DOM update on the dom tree branches, but first, for now\n        //simply to prove all the code is working we do just brute force updating here.\n        //todo-1: future optimization. For components that don't implement any enablement/visibilty functions, we can\n        //just only do this enablement stuff ONCE and then not do it again on that same element.\n        this.updateState();\n        this.setVisible(this.visible);\n        this.setEnabled(this.enabled);\n\n        //recursively drill down and do entire tree. For efficiency I need to modify this to be 'breadth' first?\n        //let visibleChildrenCount = 0;\n        util.forEachArrElm(this.children, function (child, idx) {\n            if (child) {\n                child.refreshState();\n                // if (child.visible) {\n                //     visibleChildrenCount++;\n                // }\n            }\n        });\n    }\n\n    setDomAttr = (attrName: string, attrVal: string) => {\n        this.whenElm((elm) => {\n            elm.setAttribute(attrName, attrVal);\n            this.attribs[attrName] = attrVal;\n        });\n    }\n\n    bindOnClick = (callback: Function) => {\n        domBind.addOnClick(this.getId(), callback);\n    }\n\n    setIsEnabledFunc(isEnabledFunc: Function) {\n        this.isEnabledFunc = isEnabledFunc;\n    }\n\n    setIsVisibleFunc(isVisibleFunc: Function) {\n        this.isVisibleFunc = isVisibleFunc;\n    }\n\n    /* returns true if anything was done. Should I eventually make this return true if something CHAGNED ? */\n    updateState(): boolean {\n        let ret = false;\n\n        if (this.isEnabledFunc) {\n            this.enabled = this.isEnabledFunc();\n            ret = true;\n        }\n\n        if (this.isVisibleFunc) {\n            this.visible = this.isVisibleFunc();\n            ret = true;\n        }\n        return ret;\n    }\n\n    /* Certain components decide if they are visible based on if any children are visible so we encapsulated that logic into here */\n    setVisibleIfAnyChildrenVisible() {\n        let thisVisible = false;\n\n        util.forEachArrElm(this.children, function (child, idx) {\n            if (child) {\n                /* if we found a visible child, we can set visible to true, and end this forEach iteration, because we don't need any\n                more info. We're done. It's gonna be visible */\n                if (child.visible) {\n                    thisVisible = true;\n                    return false;\n                }\n            }\n        });\n\n        this.setVisible(thisVisible);\n    }\n\n    static nextGuid(): number {\n        return ++Comp.guid;\n    }\n\n    static findById(id: string): Comp {\n        return Comp.idToCompMap[id];\n    }\n\n    removeAllChildren = (): void => {\n        this.children = [];\n    }\n\n    getId = (): string => {\n        return (<any>this.attribs).id;\n    }\n\n    /* Warning: Under lots of circumstances it's better to call domBind.whenElm rather than getElement() because getElement returns\n    null unless the element is already created and rendered onto the DOM */\n    getElement = (): HTMLElement => {\n        return <HTMLElement>document.querySelector(\"#\" + this.getId());\n    }\n\n    whenElm = (func: Function) => {\n        domBind.whenElm(this.getId(), func);\n    }\n\n    /* WARNING: this is NOT a setter for 'this.visible'. Perhaps i need to rename it for better clarity, it takes\n    this.visible as its input sometimes. Slightly confusing */\n    setVisible = (visible: boolean) => {\n        domBind.whenElm(this.getId(), (elm) => {\n            util.setElmDisplay(elm, visible);\n        });\n    }\n\n    /* WARNING: this is NOT the setter for 'this.enabled' */\n    setEnabled = (enabled: boolean) => {\n        domBind.whenElm(this.getId(), (elm) => {\n            (<any>elm).disabled = !enabled;\n        });\n    }\n\n    setClass = (clazz: string): void => {\n        (<any>this.attribs).class = clazz;\n    }\n\n    setOnClick = (onclick: Function): void => {\n        (<any>this.attribs).onclick = onclick;\n    }\n\n    /* If caller happens to have this element it can be passed, to avoid one DOM lookup */\n    renderToDom = (elm?: HTMLElement): void => {\n        if (this.renderPending) return;\n\n        /* To be synchronous where possible we go ahead and check to see if the\n        element exists right now, and if so we render and don't rely on domBind async */\n        elm = elm || this.getElement();\n        if (elm) {\n            elm.innerHTML = this.renderHtml();\n            return;\n        }\n\n        this.renderPending = true;\n        domBind.whenElm(this.getId(), (elm) => {\n            elm.innerHTML = this.renderHtml();\n            this.renderPending = false;\n        });\n    }\n\n    renderChildrenToDom = (elm?: HTMLElement): void => {\n        if (this.renderPending) return;\n\n        /* To be synchronous where possible we go ahead and check to see if the\n        element exists right now, and if so we render and don't rely on domBind async */\n        elm = elm || this.getElement();\n        if (elm) {\n            elm.innerHTML = this.renderChildren();\n            return;\n        }\n\n        this.renderPending = true;\n        domBind.whenElm(this.getId(), (elm) => {\n            elm.innerHTML = this.renderChildren();\n            this.renderPending = false;\n        });\n    }\n\n    setInnerHTML = (html: string) => {\n        domBind.whenElm(this.getId(), (elm) => {\n            elm.innerHTML = html;\n        });\n    }\n\n    addChild = (comp: Comp): void => {\n        this.children.push(comp);\n    }\n\n    addChildren = (comps: Comp[]): void => {\n        this.children.push.apply(this.children, comps);\n    }\n\n    setChildren = (comps: Comp[]) => {\n        this.children = comps || [];\n    }\n\n    renderChildren = (): string => {\n        if (this.isReact) {\n            throw \"Don't call renderChildren on react component. Call reactRenderChildren instead.\";\n        }\n        let html = \"\";\n        util.forEachArrElm(this.children, function (child: Comp, idx) {\n            if (child) {\n                let childRender = child.renderHtml();\n                if (childRender) {\n                    html += childRender;\n                }\n            }\n        });\n        return html;\n    }\n\n    reactRenderChildren = (): React.ReactNode[] => {\n        if (!this.isReact) {\n            throw \"Don't call reactRenderChildren on react component. Call renderChildren instead.\";\n        }\n        let ret: React.ReactNode[] = [];\n\n        //todo-1: use a mapper ('array.map(x=>{})') to perform this transformation \n        util.forEachArrElm(this.children, function (child: Comp, idx) {\n            if (child) {\n                ret.push(child.reactRender());\n            }\n        });\n        return ret;\n    }\n\n    reactRender = (): any /* React.DetailedReactHTMLElement???? */ => {\n        return null;\n    }\n\n    /* This returns an empty DIV that will have ReactJS content rendered into it if 'isReact' is true. This is only \n    a clean approach, because we have a rule that our TSWidgets (non-react compoents) are allowed to contain React elements, \n    but React elements are NOT allowed to contain non-react elements. This works fine for my purposes, because I know that any \n    React elements i have will be PURE react */\n    renderHtml = (): string => {\n        if (this.isReact) {\n            this.whenElm(() => {\n                ReactDOM.render(this.reactRender(), document.getElementById(this.getId()));\n            });\n\n            return tag.div(this.attribs, \"\");\n        }\n        else {\n            return this.renderChildren();\n        }\n    }\n}\n"]}