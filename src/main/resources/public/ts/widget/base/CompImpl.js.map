{"version":3,"file":"CompImpl.js","sourceRoot":"","sources":["CompImpl.ts"],"names":[],"mappings":";;AAAA,OAAO,CAAC,GAAG,CAAC,aAAa,CAAC,CAAC","sourcesContent":["console.log(\"CompImpl.ts\");\n\nexport interface CompImpl {\n\n    //constructor(attribs: Object, isReact: boolean);\n\n    refreshState(): void;\n\n    setDomAttr(attrName: string, attrVal: string);\n\n    bindOnClick(callback: Function); \n\n    setIsEnabledFunc(isEnabledFunc: Function); \n\n    setIsVisibleFunc(isVisibleFunc: Function);\n\n    updateState(): boolean;\n\n    setVisibleIfAnyChildrenVisible(); \n\n    // nextGuid(): number;\n    // findById(id: string): CompImpl; \n\n    removeAllChildren(): void;\n\n    getId(): string;\n\n    getElement(): HTMLElement; \n\n    whenElm(func: Function); \n\n    setVisible(visible: boolean); \n\n    setEnabled(enabled: boolean);\n\n    setClass(clazz: string): void; \n\n    setOnClick(onclick: Function): void; \n\n    renderToDom(elm?: HTMLElement): void;\n\n    renderChildrenToDom(elm?: HTMLElement): void;\n\n    setInnerHTML(html: string); \n\n    // addChild(comp: Comp): void \n\n    // addChildren(comps: Comp[]): void \n\n    // setChildren(comps: Comp[]) \n\n    renderChildren(): string;\n\n    //don't have interface for this yet.\n    //reactRenderChildren = (): React.ReactNode[] \n\n    reactRender(): any; /* React.DetailedReactHTMLElement???? */ \n\n    /* This returns an empty DIV that will have ReactJS content rendered into it if 'isReact' is true. This is only \n    a clean approach, because we have a rule that our TSWidgets (non-react compoents) are allowed to contain React elements, \n    but React elements are NOT allowed to contain non-react elements. This works fine for my purposes, because I know that any \n    React elements i have will be PURE react */ \n    renderHtml(): string;\n}\n"]}